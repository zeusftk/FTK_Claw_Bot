# 服务模块开发规范和指南

本文档描述如何在 `services` 目录下添加新的本地服务。

---

## 目录结构

每个服务应该有自己的子目录，结构如下：

```
services/
├── __init__.py              # 服务模块入口，导入和注册所有服务
├── service_registry.py      # 服务注册表和协议定义
├── embedding/               # Embedding 服务示例
│   ├── __init__.py         # 模块入口
│   ├── service.py          # 服务主类
│   ├── server.py           # 服务器实现（如 FastAPI）
│   └── embedder.py         # 核心功能实现
└── your_service/           # 你的服务
    ├── __init__.py
    ├── service.py
    └── ...
```

---

## 服务协议

所有服务必须实现 `LocalService` 协议：

```python
class LocalService(Protocol):
    """服务协议 - 无需继承，只需实现这些方法"""
    
    @property
    def id(self) -> str:
        """服务唯一标识符"""
        ...
    
    @property
    def name(self) -> str:
        """服务显示名称"""
        ...
    
    @property
    def description(self) -> str:
        """服务描述"""
        ...
    
    def start(self) -> bool:
        """启动服务（非阻塞）"""
        ...
    
    def stop(self) -> bool:
        """停止服务"""
        ...
    
    def get_status(self) -> ServiceInfo:
        """获取服务状态"""
        ...
    
    def get_config(self) -> Dict[str, Any]:
        """获取服务配置"""
        ...
    
    def set_config(self, config: Dict[str, Any]) -> bool:
        """设置服务配置"""
        ...
```

---

## 创建新服务步骤

### 1. 创建服务目录

```bash
mkdir services/your_service
```

### 2. 创建 `__init__.py`

```python
from .service import YourService, register_your_service

__all__ = ["YourService", "register_your_service"]
```

### 3. 创建 `service.py`

```python
import threading
import multiprocessing
from typing import Dict, Any, Optional

from loguru import logger

from ..service_registry import (
    ServiceInfo, ServiceStatus, register_service, LocalService
)


class YourService:
    """你的服务描述"""
    
    def __init__(self, port: int = 9000):
        self._port = port
        self._status = ServiceStatus.STOPPED
        self._error: Optional[str] = None
        self._process: Optional[multiprocessing.Process] = None
        self._start_lock = threading.Lock()
    
    @property
    def id(self) -> str:
        return "your_service"
    
    @property
    def name(self) -> str:
        return "你的服务"
    
    @property
    def description(self) -> str:
        return "服务描述"
    
    def start(self) -> bool:
        """启动服务（非阻塞）"""
        with self._start_lock:
            if self._status in (ServiceStatus.RUNNING, ServiceStatus.STARTING):
                return True
            
            if self._process and self._process.is_alive():
                return True
            
            try:
                self._status = ServiceStatus.STARTING
                self._error = None
                
                # 启动独立进程
                self._process = multiprocessing.Process(
                    target=self._run_server,
                    args=(self._port,),
                    daemon=True
                )
                self._process.start()
                
                logger.info(f"{self.name} 进程已启动，PID: {self._process.pid}")
                return True
                
            except Exception as e:
                self._status = ServiceStatus.ERROR
                self._error = str(e)
                logger.exception(f"{self.name} 启动异常: {e}")
                return False
    
    def check_started(self) -> bool:
        """检查服务是否已启动"""
        if self._status == ServiceStatus.RUNNING:
            return True
        
        # 实现健康检查逻辑
        if self._health_check():
            with self._start_lock:
                self._status = ServiceStatus.RUNNING
            return True
        
        if self._process and not self._process.is_alive():
            with self._start_lock:
                self._status = ServiceStatus.ERROR
                self._error = "进程已退出"
        
        return False
    
    def stop(self) -> bool:
        with self._start_lock:
            if self._process and self._process.is_alive():
                self._process.terminate()
                self._process.join(timeout=5)
                if self._process.is_alive():
                    self._process.kill()
            self._process = None
            self._status = ServiceStatus.STOPPED
        return True
    
    def get_status(self) -> ServiceInfo:
        return ServiceInfo(
            id=self.id,
            name=self.name,
            description=self.description,
            status=self._status,
            port=self._port,
            error=self._error
        )
    
    def get_config(self) -> Dict[str, Any]:
        return {"port": self._port}
    
    def set_config(self, config: Dict[str, Any]) -> bool:
        if "port" in config and self._status == ServiceStatus.STOPPED:
            self._port = config["port"]
        return True
    
    def _health_check(self) -> bool:
        """健康检查"""
        import requests
        try:
            r = requests.get(f"http://localhost:{self._port}/health", timeout=2)
            return r.status_code == 200
        except:
            return False
    
    @staticmethod
    def _run_server(port: int):
        """在独立进程中运行服务器"""
        # 实现服务器启动逻辑
        pass


_service_instance: Optional[YourService] = None


def register_your_service(port: int = 9000) -> YourService:
    """注册服务"""
    global _service_instance
    if _service_instance is None:
        _service_instance = YourService(port=port)
        register_service(_service_instance)
        
        # 如果需要自启动，取消下面的注释
        # from ..service_registry import ServiceRegistry
        # ServiceRegistry.register_auto_start("your_service")
    
    return _service_instance
```

### 4. 在 `services/__init__.py` 中注册

```python
from .your_service import register_your_service, YourService

register_your_service()

__all__ = [
    # ... 其他服务
    "YourService",
]
```

---

## 自启动服务

如果服务需要在应用启动后自动启动，在注册函数中添加：

```python
def register_your_service(port: int = 9000) -> YourService:
    global _service_instance
    if _service_instance is None:
        _service_instance = YourService(port=port)
        register_service(_service_instance)
        
        # 注册为自启动服务
        from ..service_registry import ServiceRegistry
        ServiceRegistry.register_auto_start("your_service")
    
    return _service_instance
```

自启动服务会在 `APP_STARTED` 事件后延迟 3 秒启动。

---

## 多进程注意事项

### Windows 平台

Windows 使用 `spawn` 模式创建子进程，需要注意：

1. **入口点保护**：在 `main.py` 中添加：

```python
if __name__ == "__main__":
    import multiprocessing
    multiprocessing.freeze_support()
    main()
```

2. **避免模块级代码执行**：子进程会重新导入所有模块，避免在模块级别执行副作用代码。

3. **使用独立函数**：`multiprocessing.Process` 的 `target` 应该是模块级函数，而不是实例方法。

### 正确做法

```python
# 模块级函数
def _run_server_process(port: int):
    """在独立进程中运行"""
    # ...

class YourService:
    def start(self) -> bool:
        self._process = multiprocessing.Process(
            target=_run_server_process,  # 使用模块级函数
            args=(self._port,),
            daemon=True
        )
        self._process.start()
```

### 错误做法

```python
class YourService:
    def _run_server(self, port: int):
        # 实例方法在子进程中可能无法正确序列化
        pass
    
    def start(self) -> bool:
        self._process = multiprocessing.Process(
            target=self._run_server,  # 错误：实例方法
            args=(self._port,),
            daemon=True
        )
```

---

## 状态管理

### 服务状态

```python
class ServiceStatus(Enum):
    STOPPED = "stopped"      # 已停止
    STARTING = "starting"    # 启动中
    RUNNING = "running"      # 运行中
    ERROR = "error"          # 错误
```

### 状态转换

```
STOPPED → STARTING → RUNNING
    ↑         ↓         ↓
    └────── ERROR ←────┘
```

### 线程安全

使用 `threading.Lock` 保护状态更新：

```python
def check_started(self) -> bool:
    if self._health_check():
        with self._start_lock:
            if self._status != ServiceStatus.RUNNING:
                self._status = ServiceStatus.RUNNING
        return True
```

---

## UI 集成

服务会自动显示在"本地服务"面板中。如果需要自定义 UI：

1. 在 `local_services_panel.py` 的 `_init_ui()` 方法中添加特殊处理：

```python
if service.id == "your_service":
    card = self._create_your_service_card(service)
else:
    card = self._create_service_card(service)
```

2. 创建自定义卡片方法：

```python
def _create_your_service_card(self, service) -> QFrame:
    # 自定义 UI 实现
    pass
```

---

## 最佳实践

1. **非阻塞启动**：`start()` 方法应该立即返回，使用 `check_started()` 检查是否就绪。

2. **健康检查**：实现 `_health_check()` 方法，通过 HTTP 或其他方式检查服务状态。

3. **优雅停止**：先发送停止信号，等待超时后再强制终止。

4. **错误处理**：捕获异常并设置 `_error` 字段，便于 UI 显示。

5. **日志记录**：使用 `loguru.logger` 记录关键操作。

6. **配置管理**：通过 `get_config()` 和 `set_config()` 管理服务配置。

---

## 示例参考

查看 `embedding/` 目录获取完整示例。
